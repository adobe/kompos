# Kompos Architecture

## Overview

Kompos is an infrastructure provisioning tool that combines hierarchical configuration management with runtime file generation. It separates source files (version controlled) from generated files (runtime artifacts).

## Directory Structure

Kompos maintains a clear separation between source and runtime:

```
project/
├── config/                                    # Hierarchical configuration (source)
│   ├── default.yaml
│   └── env=dev/
│       └── cluster=cluster1/
│           └── composition=terraform/
│               └── terraform=vpc/
│                   └── cluster.yaml           # Configuration values
│
├── compositions/terraform/aws/vpc/            # Source files (version controlled)
│   ├── main.tf.versioned                      # Template with {{placeholders}}
│   ├── variables.tf                           # Regular Terraform code
│   └── outputs.tf                             # Regular Terraform code
│
└── .kompos-runtime/terraform/aws/vpc/         # Generated files (gitignored)
    ├── main.tf                                # ← Generated from .tf.versioned
    ├── variables.tf                           # ← Copied from source
    ├── outputs.tf                             # ← Copied from source
    ├── provider.tf.json                       # ← Generated by kompos
    └── variables.tfvars.json                  # ← Generated by kompos
```

## Execution Flow

When you run `kompos config/.../composition=terraform terraform plan`:

### 1. **Lock Acquisition**
```
Acquire exclusive lock: .kompos-runtime/.lock
↓ Prevents concurrent kompos runs from interfering
```

### 2. **Runtime Directory Preparation**
```
Clean runtime directory (if exists)
  ↓
Create fresh .kompos-runtime/terraform/aws/vpc/
  ↓
Copy source .tf files → runtime directory
```

### 3. **Configuration Processing**
```
config/default.yaml
  + config/env=dev/env.yaml
  + config/.../cluster.yaml
  ↓
Merged hierarchical config (raw_config)
```

### 4. **File Generation** (in runtime directory)

| Generated File | Source | Purpose |
|---------------|--------|---------|
| `provider.tf.json` | Config `provider` + `terraform` keys | Terraform provider configuration |
| `variables.tfvars.json` | Config `config` key | Variable values for Terraform |
| `main.tf` | `main.tf.versioned` template | Interpolated module sources |
| `*.tf` (copied) | Source `*.tf` files | Regular Terraform code |

### 5. **Terraform Execution**
```bash
cd .kompos-runtime/terraform/aws/vpc/
terraform init
terraform plan -var-file="variables.tfvars.json"
```

### 6. **Lock Release**
```
Release lock and cleanup
```

## Versioned Module Sources

### Problem

Terraform's `source` parameter in module blocks is static - you cannot use variables:

```hcl
# ❌ This doesn't work
module "vpc" {
  source = "git::https://github.com/org/modules.git?ref=${var.module_version}"
}
```

This creates challenges when you want:
- Different module versions per environment (dev uses v2.0-rc, prod uses v1.5.0)
- Gradual rollouts of module updates
- Per-cluster version pinning for testing

### Solution

Kompos introduces **versioned module sources** using `.tf.versioned` template files:

#### 1. **Template File** (`main.tf.versioned`)
```hcl
module "vpc" {
  source = "git::https://github.com/org/terraform-modules.git//vpc?ref={{vpc.module_version}}"
  
  cidr_block = var.config.vpc.cidr_block
  tags       = var.config.vpc.tags
}
```

#### 2. **Hierarchical Config** (`cluster.yaml`)
```yaml
vpc:
  module_version: "v2.0.0-rc"  # Dev uses release candidate
  cidr_block: "10.0.0.0/16"
```

#### 3. **Generated File** (`main.tf`)
```hcl
module "vpc" {
  source = "git::https://github.com/org/terraform-modules.git//vpc?ref=v2.0.0-rc"
  
  cidr_block = var.config.vpc.cidr_block
  tags       = var.config.vpc.tags
}
```

### Configuration

Enable/disable in `.komposconfig.yaml`:

```yaml
terraform:
  versioned_module_sources: true  # Default: true
```

### Template Syntax

Placeholder `{{key.path}}` maps to config path `key/path`:

| Template Placeholder | Config Path | Example Value |
|---------------------|-------------|---------------|
| `{{vpc.module_version}}` | `vpc/module_version` | `"v2.0.0"` |
| `{{modules.vpc.ref}}` | `modules/vpc/ref` | `"main"` |

### Error Handling

If a required config key is missing, kompos fails with a clear error:

```
ValueError: Config key "vpc.module_version" not found for interpolation.
Line: source = "git::...?ref={{vpc.module_version}}"
Required config keys must be present when using versioned sources.
Add "vpc.module_version" to your hierarchical configuration.
```

### IDE Setup

`.tf.versioned` files need IDE configuration for syntax highlighting:

**VSCode** (`settings.json`):
```json
{
  "files.associations": {
    "*.tf.versioned": "terraform"
  }
}
```

**IntelliJ/PyCharm**:
- Settings → Editor → File Types → Terraform → Add `*.tf.versioned`

## Version Control

### ✅ Commit (Source)
- `config/**/*.yaml` - Hierarchical configuration
- `compositions/**/*.tf` - Terraform code
- `compositions/**/*.tf.versioned` - Templates
- `.komposconfig.yaml` - Kompos configuration

### ❌ Gitignore (Generated)
```gitignore
# Generated runtime directory
.kompos-runtime/

# Or if not using runtime directory:
compositions/**/provider.tf.json
compositions/**/variables.tfvars.json
```

## Key Principles

1. **Separation of Concerns**
   - Source files: What you write and version control
   - Generated files: What kompos creates at runtime

2. **Clean Builds Every Time**
   - Runtime directory is cleaned before each run
   - No stale files from previous runs
   - Fresh state guaranteed

3. **Concurrency Protection**
   - File lock prevents multiple kompos processes from interfering
   - Lock file: `.kompos-runtime/.lock`
   - Error message if another kompos is already running

4. **Runtime Generation**
   - Files are generated fresh on each run
   - Configuration changes immediately reflected

## ⚠️ Important: Terraform State

**Local Terraform state is NOT preserved between runs.**

The runtime directory (`.kompos-runtime/`) is cleaned before each execution, which means:
- ❌ `terraform.tfstate` is deleted
- ❌ `.terraform/` cache is deleted
- ❌ Any local state is lost

### Required: Use Remote State Backends

You **MUST** configure a remote state backend in your Terraform code:

```hcl
# backend.tf or main.tf
terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "vpc/terraform.tfstate"
    region = "us-east-1"
  }
}
```

**Supported backends:**
- AWS S3
- Terraform Cloud
- Azure Blob Storage
- Google Cloud Storage
- Consul
- Any other [Terraform backend](https://www.terraform.io/language/settings/backends)

**Why this matters:**
- Remote state persists across kompos runs
- State is shared across team members
- State is backed up and versioned
- This is Terraform best practice anyway

## Dry-Run Mode

Generate all files without executing Terraform:

```bash
kompos config/.../composition=terraform terraform plan --dry-run
```

**What happens:**
- ✅ Processes hierarchical configuration
- ✅ Cleans and prepares runtime directory
- ✅ Copies source `.tf` files
- ✅ Interpolates `.tf.versioned` → `.tf` files
- ✅ Generates `provider.tf.json`
- ✅ Generates `variables.tfvars.json`
- ❌ Skips `terraform init` and `terraform plan`

**Use cases:**
- Verify interpolation results
- Debug configuration issues
- CI/CD validation without execution
- Preview what will be generated

## Example Usage

### Basic Terraform Run

```bash
# Run terraform plan for dev cluster
kompos config/env=dev/cluster=cluster1/composition=terraform terraform plan

# Run terraform apply for prod cluster
kompos config/env=prod/cluster=prod1/composition=terraform terraform apply
```

### With Versioned Module Sources

**Dev environment** (`config/env=dev/cluster=cluster1/cluster.yaml`):
```yaml
vpc:
  module_version: "v2.0.0-rc"  # Testing release candidate
  cidr_block: "10.0.0.0/16"
```

**Prod environment** (`config/env=prod/cluster=prod1/cluster.yaml`):
```yaml
vpc:
  module_version: "v1.5.0"  # Stable version
  cidr_block: "10.1.0.0/16"
```

Same template file (`compositions/terraform/vpc/main.tf.versioned`) works for both!

### Dry-Run

```bash
# Generate files but don't run terraform
kompos config/env=dev/cluster=cluster1/composition=terraform terraform plan --dry-run

# Check generated files
ls -la .kompos-runtime/terraform/aws/vpc/
```

## Benefits

### General
- ✅ Clean separation of source and generated files
- ✅ No stale configuration files
- ✅ Predictable, reproducible builds
- ✅ Concurrent execution protection
- ✅ Simple gitignore (just `.kompos-runtime/`)

### Versioned Module Sources
- ✅ Per-cluster/environment module versions
- ✅ Gradual rollouts (test in dev, promote to prod)
- ✅ Single source of truth (version in config, not code)
- ✅ No code duplication across environments
- ✅ Terraform limitation overcome without wrappers

## Best Practices

1. **Always use remote state backends**
   - Required for production use
   - Enables team collaboration
   - Prevents state loss

2. **Version lock for production**
   ```yaml
   # dev - test new versions
   vpc.module_version: "v2.1.0-rc"
   
   # prod - locked to stable
   vpc.module_version: "v2.0.0"
   ```

3. **Document required config keys**
   ```hcl
   # Requires: vpc.module_version, vpc.cidr_block
   module "vpc" {
     source = "...?ref={{vpc.module_version}}"
     cidr = var.config.vpc.cidr_block
   }
   ```

4. **Use semantic versioning** for module refs
   ```yaml
   vpc:
     module_version: "v2.0.0"  # ✅ Explicit
     # module_version: "main"  # ⚠️ Avoid - non-deterministic
   ```

5. **Test in dev before prod**
   - Deploy new module version to dev
   - Validate functionality
   - Promote same version to prod config

